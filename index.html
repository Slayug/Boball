<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Bobowl</title>
</head>

<style>
body {
	margin:0px;
padding:0px;
cursor:url("mouse.png"), default;

}
</style>

<body onselectstart="return false"  oncontextmenu="return false">

<canvas onmousemove="mouseMove(event)" onmouseup="mouseClicked(event)" id="canvasGame">
</canvas>

<script src="http://code.jquery.com/jquery-1.10.1.min.js"></script>

<script type="text/javascript">
var lastFrameTimeMs = 0;
var maxFPS = 120;
var delta = 0;
var timestep = 1000 / 120;
var fps = 120;
var framesThisSecond = 0;
var lastFpsUpdate = 0;
/**
 * requestAnimationFrame
 */
window.requestAnimationFrame = (function(){
    return  window.requestAnimationFrame       ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame    ||
            window.oRequestAnimationFrame      ||
            window.msRequestAnimationFrame     ||
            function (callback) {
                window.setTimeout(callback, 1000 / 60);
            };
})();
if (!Date.now) {
  Date.now = function now() {
    return new Date().getTime();
  };
}
var elem = document.getElementById('canvasGame');

var ctx = elem.getContext('2d');
function random(min, max){
	return (Math.random() * max | 0) + min;
}
function mouseClicked(e){
    hasClicked = true;
	if(!lostLevel)
		levels[currentLevel].eventMouseClicked(e);
}
var xMouse = 0;
var yMouse = 0;
function mouseMove(e){
	xMouse = e.clientX;
	yMouse = e.clientY;
}
var w = window,
e = document.documentElement,
g = document.getElementsByTagName('body')[0],
heightW = w.innerHeight|| e.clientHeight|| g.clientHeight;
var  widthW = w.innerWidth|| e.clientWidth|| g.clientWidth;
ctx.canvas.width = widthW - 0;
ctx.canvas.height = heightW - 4;
var WIDTH = widthW;
var HEIGHT = heightW - 4;
var hasClicked = false;
var alpha = 0;
var Point = function(x, y, color, dx, dy, speedX, speedY){
	this.x = x;
	this.y = y;
	if(dx == undefined)
		this.dx = parseInt(Math.random()*100)/100;
	else
		this.dx = dx;
	if(dy == undefined)
		this.dy = parseInt(Math.random()*100)/100;
	else
		this.dy = dy;
	console.log(this.dx);
	console.log(this.dy);
	if(color == undefined){
		this.color = randomColor();
	}else{
		this.color = color;
	}
	if(speedX == undefined){
		this.speedX = random(2, 7);
	}else{
		this.speedX = speedX;
	}
	var inv = random(1, 2);
	if(inv == 1){
		this.dx *= -1;
	}
	inv = random(1, 2);
	if(inv == 1){
		this.dy *= -1;
	}
	if(speedY == undefined){
		this.speedY = random(2, 7);
	}else{
		this.speedY = speedY;
	}
	this.radius = 4;
	this.inCollision = function(oPoint){
		var distance = Math.sqrt((this.x - oPoint.x) *
				(this.x - oPoint.x) +
				(this.y - oPoint.y) *
				(this.y - oPoint.y));
		if(distance < this.radius + oPoint.radius){
			return true;
		}
		return false;
	}
}
var colors = ['#b543de', '#FF4B47', '#40E64F',
				'#E0C93B', '#F58F39', '#39BAC5',
				'#e63192'];
function randomColor(){
	var rdm = Math.round(Math.random()*(colors.length-1));
	return colors[rdm];
	var color = '#';
	for(var c = 0; c < 6; c++){
		color += rdm;
		rdm = Math.round(Math.random()*10);
	}
	return color;
}
var points = [];
var pointsTouched = [];
var mousePoints = [];
var currentLevel = 2;
var levels = [];


function Level(goal, fctGeneration, logic, draw, fctMouseClicked){
	this.goal = goal;
	this.bowlsPlaced = 0;
	//methods
	this.generation = fctGeneration;
	this.logic = logic;
	this.draw = draw;
	this.eventMouseClicked = fctMouseClicked;
}
levels.push(new Level('Place one bowl and capture an other with the first !',
	function(){
		for(var p = 0; p < 72; p++){
			points.push(new Point(WIDTH/2,HEIGHT/2));
		}
		this.ready = false;
	},
	function(){ //LOGIC
		if(!this.ready){
			if(hasClicked){
				this.ready = true;
			}else{
				return;
			}
		}

		var mouseNeedDeleted = -1;
		for(var p = 0; p < mousePoints.length; p++){
			mousePoints[p].radius+=0.1;
			if(mousePoints[p].radius >= 14){
				mouseNeedDeleted = p;
			}
		}
		if(mouseNeedDeleted >= 0){
			mousePoints.splice(mouseNeedDeleted, 1);
		}

		for(var p = 0; p < points.length; p++){
			for(var m = 0; m < mousePoints.length; m++){
				if(points[p].inCollision(mousePoints[m]) &&
						pointsTouched.indexOf(mousePoints[m]) == -1){
					points[p].color = 'white';
					pointsTouched.push(points[p]);
				}
			}
		}
		if(pointsTouched.length >= 1){
			nextLevel();
		}
	},
	function(){ //DRAW
		if(!this.ready){

			ctx.strokeStyle="white";
			ctx.lineWidth="10";
			ctx.moveTo(200, 55);
			ctx.lineTo(200, HEIGHT * 0.42);
			ctx.moveTo(202, 55);
			ctx.lineTo(150, 100);
			ctx.moveTo(198, 55);
			ctx.lineTo(250, 100);
			ctx.stroke();
			ctx.fillText('LEVEL INSTRUCTION', 100, HEIGHT * 0.42 + 25);

			ctx.shadowColor = randomColor();
			ctx.shadowBlur="50";
			ctx.font = '42px serif';
			ctx.fillText('Mouse Left: Put one bowl', WIDTH/2 - 160, HEIGHT/2 - 20);
			ctx.fillText('Mouse Right: Inverse the time', WIDTH/2 - 185, HEIGHT/2 + 22);
			ctx.fillText('Click to start.', WIDTH/2 - 50, HEIGHT/2 + 62);
		}
	},
	function(e){ //MOUSECLIKED
		if(!this.ready)
			return;
		if(e.button > 0){
			for(var p = 0; p < points.length; p++){
				points[p].speedX *= -1;
				points[p].speedY *= -1;
			}
		}else{
			mousePoints.push(new Point(e.clientX, e.clientY));
		}
	}));
levels.push(new Level('3 Bowls this time !',
		function(){
	for(var p = 0; p < 16; p++){
		points.push(new Point(WIDTH/2,HEIGHT/2));
	}this.bowlsPlaced = 0;
    },
	function(){ //LOGIC

		var mouseNeedDeleted = -1;
		for(var p = 0; p < mousePoints.length; p++){
			mousePoints[p].radius+=0.1;
			if(mousePoints[p].radius >= 14){
				mouseNeedDeleted = p;
			}
		}
		if(mouseNeedDeleted >= 0){
			mousePoints.splice(mouseNeedDeleted, 1);
		}

		for(var p = 0; p < points.length; p++){
			for(var m = 0; m < mousePoints.length; m++){
				if(points[p].inCollision(mousePoints[m]) &&
						pointsTouched.indexOf(points[p]) == -1){
					points[p].color = 'white';
					pointsTouched.push(points[p]);
				}
			}
		}
        if(this.bowlsPlaced > 2 && mousePoints.length == 0){
            lost();
            return;
        }
		if(pointsTouched.length >= 3){
			nextLevel();
		}
	},
	function(){ //DRAW
	},
	function(e){ //MOUSECLIKED
		if(e.button > 0){
			for(var p = 0; p < points.length; p++){
				points[p].speedX *= -1;
				points[p].speedY *= -1;
			}
		}else{
		if(this.bowlsPlaced < 3){
    		mousePoints.push(new Point(e.clientX, e.clientY));
    		this.bowlsPlaced++;
		}}
	}));
levels.push(new Level('Try 3 red bowls !',
			function(){
		for(var p = 0; p < 10; p++){
			var color = randomColor();
			while(color == '#FF4B47'){
				color = randomColor();
			}
			points.push(new Point(WIDTH/2,HEIGHT/2, color));
		}
		for(var p = points.length; p < 20; p++){
			points.push(new Point(WIDTH/2,HEIGHT/2, '#FF4B47'));
		}
		this.bowlsPlaced = 0;
	    },
		function(){ //LOGIC
			if(alpha <= Math.PI){
				alpha += 0.02;
				animations['win'].logic();
				return;
			}

			var mouseNeedDeleted = -1;
			for(var p = 0; p < mousePoints.length; p++){
				mousePoints[p].radius+=0.1;
				if(mousePoints[p].radius >= 14){
					mouseNeedDeleted = p;
				}
			}
			if(mouseNeedDeleted >= 0){
				mousePoints.splice(mouseNeedDeleted, 1);
			}

			for(var p = 0; p < points.length; p++){
				for(var m = 0; m < mousePoints.length; m++){
					if(points[p].inCollision(mousePoints[m]) &&
							pointsTouched.indexOf(points[p]) == -1
							&& points[p].color == '#FF4B47'){
						points[p].color = 'white';
						pointsTouched.push(points[p]);
					}
				}
			}
	        if(this.bowlsPlaced > 4 && mousePoints.length == 0){
	            lost();
	            return;
	        }
			if(pointsTouched.length >= 3){
				nextLevel();
			}
		},
		function(){ //DRAW
			if(alpha <= Math.PI){
				ctx.shadowColor = 'white';
		        ctx.shadowBlur = animations['win'].step;
				ctx.font = '42px serif';
		        ctx.fillText('LOADING', WIDTH/2 - 55, HEIGHT/2);
			}
		},
		function(e){ //MOUSECLIKED
			if(alpha <= Math.PI)
				return;
			if(e.button > 0){
				for(var p = 0; p < points.length; p++){
					points[p].speedX *= -1;
					points[p].speedY *= -1;
				}
			}else{
				if(this.bowlsPlaced < 5){
		    		mousePoints.push(new Point(e.clientX, e.clientY));
		    		this.bowlsPlaced++;
				}
			}
}));
levels.push(new Level('You have a new power, place two bowls to try. After that capture 5 bowls with those arcs.',
			function(){
		var rdmDx = parseInt(Math.random()*10)/10;
		var rdmDy = parseInt(Math.random()*10)/10;
		for(var p = 0; p < 4; p++){
			points.push(new Point(WIDTH/2,HEIGHT/2, randomColor(), rdmDx, rdmDy));
		}
		this.bowlsPlaced = 0;
		this.firstClick = false;
	    },
		function(){ //LOGIC
			if(alpha < 2*Math.PI){
				alpha += 0.02;
				animations['win'].logic();
				return;
			}

			for(var p = 0; p < mousePoints.length; p++){
				if(mousePoints[p].radius < 14){
					mousePoints[p].radius+=0.1;
				}
			}


			for(var m = 0; m < mousePoints.length; m++){
				if(m % 2 != 0){
					var a = (mousePoints[m-1].y - mousePoints[m].y) /
						(mousePoints[m-1].x - mousePoints[m].x);
					var b = a * mousePoints[m].x - mousePoints[m].y;

					for(var p = 0; p < points.length; p++){
						if(a * points[p].x + b == points[p].y){
							console.log('coll');
						}
					}
				}
			}
	        if(this.bowlsPlaced > 4 && mousePoints.length == 0){
	            lost();
	            return;
	        }
			if(pointsTouched.length >= 3){
				//nextLevel();
			}
		},
		function(){ //DRAW
			if(alpha < 2*Math.PI){
				ctx.shadowColor = 'white';
		        ctx.shadowBlur = animations['win'].step;
				ctx.font = '42px serif';
		        ctx.fillText('LOADING', WIDTH/2 - 55, HEIGHT/2);
			}else{
				ctx.beginPath();
				ctx.lineWidth = 4;
				ctx.strokeStyle='white';
				for(var m = 0; m < mousePoints.length; m++){
					if(m % 2 != 0){
						ctx.moveTo(mousePoints[m-1].x, mousePoints[m-1].y);
						ctx.lineTo(mousePoints[m].x, mousePoints[m].y);
					}
				}
				ctx.stroke();
			}
		},
		function(e){ //MOUSECLIKED
			if(alpha < 2*Math.PI)
				return;
			if(!this.firstClick){
				new Message('Oups, sorry i have one bug with this click..',
							100, 100, 7000, null);
				new Message('Deal with it !',
							100, 140, 7000, null);
				this.firstClick = true;
			}
			for(var p = 0; p < points.length; p++){
				points[p].speedX *= -1;
				points[p].speedY *= -1;
			}
			if(e.button == 0){
				if(this.bowlsPlaced < 4){
		    		mousePoints.push(new Point(e.clientX, e.clientY));
		    		this.bowlsPlaced++;
				}else{
					lost();
					hasClicked = false;
					return;
				}
			}
}));


function nextLevel(){
	reset();
	if(currentLevel == levels.length - 1){
        win = true;
		return;
	}
	levels[++currentLevel].generation();
}

function reset(){
	points = [];
	pointsTouched = [];
	mousePoints = [];
}
var lostLevel = false;
var win = false;
function lost(){
	lostLevel = true;
}
function hexToRgb(hex) {
	hex = hex.replace('#', '');
    var bigint = parseInt(hex, 16);
	return {
		r: (bigint >> 16) & 255,
		g: (bigint >> 8) & 255,
		b: bigint & 255
	};
}

var messages = [];
//time in ms
//animation str
function Message(msg, x, y, time, animation){
	this.msg = msg;
	this.x = x;
	this.y = y;
	this.time = time;
	this.animation = animation;
	this.logic = function(){
		if(this.startTime + this.time < Date.now()){
			messages.splice(messages.indexOf(this), 1);
			return;
		}
		if(this.animation != null)
			animations[this.animation].logic();
	}
	this.draw = function(){
		ctx.font = '30px serif';
		ctx.fillText(this.msg, this.x, this.y);
	}
	this.startTime = Date.now();
	messages.push(this);
}
function Animation(start, end, bearing){
    this.start = start;
    this.sens = 1;
    this.step = start;
    this.bearing = bearing;
    this.end = end;
    this.logic = function(){
        if(this.step > this.end-1){
            this.sens *= -1;
        }else if(this.step < this.start){
            this.sens *= -1;
        }
        this.step += (this.bearing * this.sens);
    }
}
var animations = [];
animations['lost'] = new Animation(0, 16, 0.4);
animations['win'] = animations['lost'];

nextLevel();
function loop(timestamp){
	// Throttle the frame rate.
	if (timestamp < lastFrameTimeMs + (1000 / maxFPS)) {
		requestAnimationFrame(loop);
		return;
	}
	delta += timestamp - lastFrameTimeMs;
	lastFrameTimeMs = timestamp;

	if (timestamp > lastFpsUpdate + 1000) {
		fps = 0.25 * framesThisSecond + 0.75 * fps;

		lastFpsUpdate = timestamp;
		framesThisSecond = 0;
	}
	framesThisSecond++;
	var numUpdateSteps = 0;
	while (delta >= timestep) {
		update(timestep);
		delta -= timestep;
		if (++numUpdateSteps >= 240) {
			panic();
			break;
		}
	}
	draw();
	requestAnimationFrame(loop);
}
function draw(){

		ctx.fillStyle = 'black';
		ctx.fillRect(0, 0, WIDTH, HEIGHT);
		//ctx.clearRect(0, 0, WIDTH, HEIGHT);

		ctx.fillStyle = 'white';
	    ctx.shadowBlur = 0;
		ctx.font = '24px serif';
		ctx.fillText(levels[currentLevel].goal, 22, 30);
	    if(lostLevel){
	        ctx.fillStyle = 'white';
	        ctx.shadowOffsetX = 0;
	        ctx.shadowOffsetY = 0;
	        ctx.shadowColor = 'white';
	        ctx.shadowBlur = animations['lost'].step;
			ctx.font = '30px serif';
			ctx.fillText('CLICK TO', WIDTH/2 - 42, HEIGHT/2-30);
			ctx.font = '42px serif';
	        ctx.fillText('RETRY', WIDTH/2 - 42, HEIGHT/2);
	    }else if(win){
			ctx.fillStyle = 'white';
	        ctx.font = '42px serif';
	        ctx.shadowOffsetX = 0;
	        ctx.shadowOffsetY = 0;
	        ctx.shadowColor = 'white';
	        ctx.shadowBlur = animations['win'].step;
			ctx.font = '72px serif';
	        ctx.fillText('.GG HUMAN.', WIDTH/2 - 200, HEIGHT/2);
		}
		ctx.save();
		levels[currentLevel].draw();
		ctx.translate(WIDTH/2,HEIGHT/2);
		ctx.rotate(this.alpha);
		ctx.translate(-WIDTH/2,-HEIGHT/2);
	for(var p = 0; p < points.length; p++){
	//bowl
		ctx.beginPath();
		ctx.fillStyle = points[p].color;
		ctx.shadowBlur = 16;
		ctx.shadowColor = points[p].color;
		ctx.arc(points[p].x, points[p].y, points[p].radius, 0, 2 * Math.PI, false);
		ctx.fill();
	}
	ctx.beginPath();
	ctx.fillStyle = 'white';
	ctx.shadowOffsetX = 0;
	ctx.shadowOffsetY = 0;
	ctx.shadowBlur = 20;
	ctx.shadowColor = 'white';
	for(var p = 0; p < mousePoints.length; p++){
		ctx.moveTo(mousePoints[p].x, mousePoints[p].y);
		ctx.arc(mousePoints[p].x, mousePoints[p].y,
				mousePoints[p].radius+mousePoints[p].radius, 0, 2 * Math.PI, false);


	}
	ctx.fill();


	for(var m = 0; m < messages.length; m++){
		messages[m].draw();
	}

		//draw mouse
		ctx.beginPath();
		ctx.lineWidth = 9;
		ctx.fillStyle = 'white';
		ctx.shadowBlur = 1;
		ctx.arc(xMouse, yMouse, 4, 0, 2 * Math.PI, false);
		ctx.fill();

		ctx.restore();
}
function panic() {
    delta = 0;
	ctx.clearRect(0, 0, WIDTH, HEIGHT);
}
function update(){
	for(var m = 0; m < messages.length; m++){
		messages[m].logic();
	}
	for(var p = 0; p < points.length; p++){
		if(points[p].x + points[p].speedX * points[p].dx >= WIDTH){
			points[p].dx *= -1;
		}
		else if(points[p].x + points[p].speedX * points[p].dx <= 0){
			points[p].dx *= -1;
		}
		if(points[p].y + points[p].speedY * points[p].dy >= HEIGHT){
			points[p].dy *= -1;
		}
		else if(points[p].y + points[p].speedY * points[p].dy <= 0){
			points[p].dy *= -1;
		}
		points[p].x += points[p].speedX * points[p].dx;
		points[p].y += points[p].speedY * points[p].dy;
	}

    if(lostLevel){
        animations['lost'].logic();
        if(hasClicked){
            reset();
            levels[currentLevel].generation();
            lostLevel = false;
        }
    }else if(!win){
        levels[currentLevel].logic();
    }else if(win){
		animations['win'].logic();
	}
    hasClicked = false;
}
requestAnimationFrame(loop);
</script>
</body>
</html>
