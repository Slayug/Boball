<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Bobow</title>
</head>

<style>
body {
	margin:0px;
padding:0px;
cursor:url("mouse.png"), default;

}
</style>

<body>

<canvas onmousemove="mouseMove(event)" onmouseup="mouseClicked(event)" id="canvasGame">
</canvas>

<script src="http://code.jquery.com/jquery-1.10.1.min.js"></script>

<script type="text/javascript">
var lastFrameTimeMs = 0;
var maxFPS = 120;
var delta = 0;
var timestep = 1000 / 120;
var fps = 120;
var framesThisSecond = 0;
var lastFpsUpdate = 0;
/**
 * requestAnimationFrame
 */
window.requestAnimationFrame = (function(){
    return  window.requestAnimationFrame       ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame    ||
            window.oRequestAnimationFrame      ||
            window.msRequestAnimationFrame     ||
            function (callback) {
                window.setTimeout(callback, 1000 / 60);
            };
})();


var elem = document.getElementById('canvasGame');

var ctx = elem.getContext('2d');
function random(min, max){
	return (Math.random() * max | 0) + min;
}
function mouseClicked(e){
    hasClicked = true;
	if(!lostLevel)
		levels[currentLevel].eventMouseClicked(e);
}
var xMouse = 0;
var yMouse = 0;
function mouseMove(e){
	xMouse = e.clientX;
	yMouse = e.clientY;
}
var w = window,
e = document.documentElement,
g = document.getElementsByTagName('body')[0],
heightW = w.innerHeight|| e.clientHeight|| g.clientHeight;
var  widthW = w.innerWidth|| e.clientWidth|| g.clientWidth;
ctx.canvas.width = widthW - 0;
ctx.canvas.height = heightW - 4;
var WIDTH = widthW;
var HEIGHT = heightW - 4;
var hasClicked = false;
var Point = function(x, y, color, speedX, speedY){
	this.x = x;
	this.y = y;
	this.dx = parseInt(Math.random()*1000)/1000;
	this.dy = parseInt(Math.random()*1000)/1000;
	if(color == undefined){
		this.color = randomColor();
	}else{
		this.color = color;
	}
	if(speedX == undefined){
		this.speedX = random(2, 12);
	}else{
		this.speedX = speedX;
	}
	var inv = random(1, 2);
	if(inv == 1){
		this.dx *= -1;
	}
	inv = random(1, 2);
	if(inv == 1){
		this.dy *= -1;
	}
	if(speedY == undefined){
		this.speedY = random(2, 12);
	}else{
		this.speedY = speedY;
	}
	this.radius = 4;
	this.inCollision = function(oPoint){
		var distance = Math.sqrt((this.x - oPoint.x) *
				(this.x - oPoint.x) +
				(this.y - oPoint.y) *
				(this.y - oPoint.y));
		if(distance < this.radius + oPoint.radius){
			return true;
		}
		return false;
	}
}
var colors = ['#b543de', '#FF4B47', '#40E64F',
				'#E0C93B', '#F58F39', '#39BAC5',
				'#e63192'];
function randomColor(){
	var rdm = Math.round(Math.random()*(colors.length-1));
	return colors[rdm];
	var color = '#';
	for(var c = 0; c < 6; c++){
		color += rdm;
		rdm = Math.round(Math.random()*10);
	}
	return color;
}
var points = [];
var pointsTouched = [];
var mousePoints = [];
var currentLevel = -1;
var levels = [];


function Level(goal, fctGeneration, logic, draw, fctMouseClicked){
	this.goal = goal;
	this.bowlsPlaced = 0;
	//methods
	this.generation = fctGeneration;
	this.logic = logic;
	this.draw = draw;
	this.eventMouseClicked = fctMouseClicked;
}
levels.push(new Level('Touchez 1 boule !',
		function(){
	for(var p = 0; p < 72; p++){
		points.push(new Point(WIDTH/2,HEIGHT/2));
	}},
	function(){ //LOGIC
		for(var p = 0; p < points.length; p++){
			for(var m = 0; m < mousePoints.length; m++){
				if(points[p].inCollision(mousePoints[m]) &&
						pointsTouched.indexOf(mousePoints[m]) == -1){
					pointsTouched.push(points[p]);
				}
			}
		}
		if(pointsTouched.length >= 1){
			nextLevel();
		}
	},
	function(){},
	function(e){ //MOUSECLIKED
		for(var p = 0; p < points.length; p++){
			points[p].speedX *= -1;
			points[p].speedY *= -1;
		}
		mousePoints.push(new Point(e.clientX, e.clientY));
	}));
levels.push(new Level('Touchez 3 boules !',
		function(){
	for(var p = 0; p < 16; p++){
		points.push(new Point(WIDTH/2,HEIGHT/2));
	}this.bowlsPlaced = 0;
    },
	function(){ //LOGIC
		for(var p = 0; p < points.length; p++){
			for(var m = 0; m < mousePoints.length; m++){
				if(points[p].inCollision(mousePoints[m]) &&
						pointsTouched.indexOf(points[p]) == -1){
					pointsTouched.push(points[p]);
				}
			}
		}
        if(this.bowlsPlaced > 2 && mousePoints.length == 0){
            lost();
            return;
        }
		if(pointsTouched.length >= 3){
			nextLevel();
		}
	},
	function(){},
	function(e){ //MOUSECLIKED
		for(var p = 0; p < points.length; p++){
			points[p].speedX *= -1;
			points[p].speedY *= -1;
		}
		if(this.bowlsPlaced < 3){
    		mousePoints.push(new Point(e.clientX, e.clientY));
    		this.bowlsPlaced++;
		}
	}));
levels.push(new Level('Touchez 3 boules rouges !',
			function(){
		for(var p = 0; p < 10; p++){
			var color = randomColor();
			while(color == '#FF4B47'){
				color = randomColor();
			}
			points.push(new Point(WIDTH/2,HEIGHT/2, color));
		}
		for(var p = points.length; p < 20; p++){
			points.push(new Point(WIDTH/2,HEIGHT/2, '#FF4B47'));
		}
		this.bowlsPlaced = 0;
		this.alpha = 0;
	    },
		function(){ //LOGIC
			if(this.alpha <= Math.PI){
				this.alpha += 0.02;
				animations['win'].logic();
				return;
			}

			for(var p = 0; p < points.length; p++){
				for(var m = 0; m < mousePoints.length; m++){
					if(points[p].inCollision(mousePoints[m]) &&
							pointsTouched.indexOf(points[p]) == -1
							&& points[p].color == '#FF4B47'){
						pointsTouched.push(points[p]);
					}
				}
			}
	        if(this.bowlsPlaced > 4 && mousePoints.length == 0){
	            lost();
	            return;
	        }
			if(pointsTouched.length >= 3){
				nextLevel();
			}
		},
		function(){ //DRAW
			if(this.alpha <= Math.PI){
				ctx.shadowColor = 'white';
		        ctx.shadowBlur = animations['win'].step;
				ctx.font = '42px serif';
		        ctx.fillText('LOADING', WIDTH/2 - 55, HEIGHT/2);
				ctx.translate(WIDTH/2,HEIGHT/2);
			    ctx.rotate(this.alpha);
				ctx.translate(-WIDTH/2,-HEIGHT/2);
			}else{
				ctx.translate(WIDTH/2,HEIGHT/2);
			    ctx.rotate(this.alpha);
				ctx.translate(-WIDTH/2,-HEIGHT/2);
			}
		},
		function(e){ //MOUSECLIKED
			if(this.alpha <= Math.PI)
				return;
			for(var p = 0; p < points.length; p++){
				points[p].speedX *= -1;
				points[p].speedY *= -1;
			}
			if(this.bowlsPlaced < 5){
	    		mousePoints.push(new Point(e.clientX, e.clientY));
	    		this.bowlsPlaced++;
			}
}));



function nextLevel(){
	reset();
	if(currentLevel == levels.length - 1){
		console.log('WIN');
        win = true;
		return;
	}
	levels[++currentLevel].generation();
}

function reset(){
	points = [];
	pointsTouched = [];
	mousePoints = [];
}
var lostLevel = false;
var win = false;
function lost(){
	lostLevel = true;
}
function hexToRgb(hex) {
	hex = hex.replace('#', '');
    var bigint = parseInt(hex, 16);
	return {
		r: (bigint >> 16) & 255,
		g: (bigint >> 8) & 255,
		b: bigint & 255
	};
}


function Animation(start, end, bearing){
    this.start = start;
    this.sens = 1;
    this.step = start;
    this.bearing = bearing;
    this.end = end;
    this.logic = function(){
        if(this.step > this.end-1){
            this.sens *= -1;
        }else if(this.step < this.start){
            this.sens *= -1;
        }
        this.step += (this.bearing * this.sens);
    }
}
var animations = [];
animations['lost'] = new Animation(0, 16, 0.5);
animations['win'] = animations['lost'];

nextLevel();
var date = new Date();
function loop(timestamp){
	// Throttle the frame rate.
	if (timestamp < lastFrameTimeMs + (1000 / maxFPS)) {
		requestAnimationFrame(loop);
		return;
	}
	delta += timestamp - lastFrameTimeMs;
	lastFrameTimeMs = timestamp;

	if (timestamp > lastFpsUpdate + 1000) {
		fps = 0.25 * framesThisSecond + 0.75 * fps;

		lastFpsUpdate = timestamp;
		framesThisSecond = 0;
	}
	framesThisSecond++;
	var numUpdateSteps = 0;
	while (delta >= timestep) {
		update(timestep);
		delta -= timestep;
		if (++numUpdateSteps >= 240) {
			panic();
			break;
		}
	}
	draw();
	requestAnimationFrame(loop);
}
function draw(){

		ctx.fillStyle = 'black';
		ctx.fillRect(0, 0, WIDTH, HEIGHT);
		ctx.fillStyle = 'white';
	    ctx.shadowBlur = 0;
		ctx.font = '24px serif';
		ctx.fillText(levels[currentLevel].goal, 22, 30);
	    if(lostLevel){
	        ctx.fillStyle = 'white';
	        ctx.shadowOffsetX = 0;
	        ctx.shadowOffsetY = 0;
	        ctx.shadowColor = 'white';
	        ctx.shadowBlur = animations['lost'].step;
			ctx.font = '30px serif';
			ctx.fillText('CLICK TO', WIDTH/2 - 42, HEIGHT/2-30);
			ctx.font = '42px serif';
	        ctx.fillText('RETRY', WIDTH/2 - 42, HEIGHT/2);
	    }else if(win){
			ctx.fillStyle = 'white';
	        ctx.font = '42px serif';
	        ctx.shadowOffsetX = 0;
	        ctx.shadowOffsetY = 0;
	        ctx.shadowColor = 'white';
	        ctx.shadowBlur = animations['win'].step;
			ctx.font = '72px serif';
	        ctx.fillText('.GG HUMAN.', WIDTH/2 - 200, HEIGHT/2);
		}
		ctx.save();
		levels[currentLevel].draw();

		/*for(var p = 0; p < points.length; p++){
			// add linear gradient
			ctx.beginPath();
			var grd = ctx.createRadialGradient(
						points[p].x, points[p].y,
						points[p].radius,
						points[p].radius + points[p].dx*-60,
						points[p].radius + points[p].dy*-60,
						points[p].radius);
			var rgb = hexToRgb(points[p].color);
			grd.addColorStop(0, 'rgba('+rgb.r+','+rgb.g+','+rgb.b+', 0.1)');
			grd.addColorStop(1, 'rgba('+rgb.r+','+rgb.g+','+rgb.b+', 1)');
			ctx.strokeStyle = grd;
			ctx.lineWidth = points[p].radius*2;
			ctx.moveTo(points[p].x,points[p].y);
			ctx.lineTo(points[p].x + points[p].dx * -60,
						points[p].y + points[p].dy * -60);
			ctx.stroke();
		}
	*/
		for(var p = 0; p < points.length; p++){
		//bowl
			ctx.beginPath();
			ctx.fillStyle = points[p].color;
			ctx.shadowBlur = 16;
			ctx.shadowColor = points[p].color;
			ctx.arc(points[p].x, points[p].y, points[p].radius, 0, 2 * Math.PI, false);
			ctx.fill();
		}

		ctx.beginPath();
		ctx.fillStyle = 'white';
		ctx.shadowOffsetX = 0;
		ctx.shadowOffsetY = 0;
		ctx.shadowBlur = 20;
		ctx.shadowColor = 'white';
		for(var p = 0; p < mousePoints.length; p++){
			ctx.moveTo(mousePoints[p].x, mousePoints[p].y);
			ctx.arc(mousePoints[p].x, mousePoints[p].y,
					mousePoints[p].radius+mousePoints[p].radius, 0, 2 * Math.PI, false);

		}
		ctx.fill();

		//draw mouse
		ctx.beginPath();
		ctx.lineWidth = 9;
		ctx.fillStyle = 'white';
		ctx.shadowBlur = 1;
		ctx.arc(xMouse, yMouse, 4, 0, 2 * Math.PI, false);
		ctx.fill();

		ctx.restore();
}
requestAnimationFrame(loop);

function update(){
	date = new Date();
	for(var p = 0; p < points.length; p++){
		if(points[p].x + points[p].speedX * points[p].dx >= WIDTH){
			points[p].dx *= -1;
		}
		else if(points[p].x + points[p].speedX * points[p].dx <= 0){
			points[p].dx *= -1;
		}
		if(points[p].y + points[p].speedY * points[p].dy >= HEIGHT){
			points[p].dy *= -1;
		}
		else if(points[p].y + points[p].speedY * points[p].dy <= 0){
			points[p].dy *= -1;
		}
		points[p].x += points[p].speedX * points[p].dx;
		points[p].y += points[p].speedY * points[p].dy;
	}
	var mouseNeedDeleted = -1;
	for(var p = 0; p < mousePoints.length; p++){
		mousePoints[p].radius+=0.2;
		if(mousePoints[p].radius >= 14){
			mouseNeedDeleted = p;
		}
	}
	if(mouseNeedDeleted >= 0){
		mousePoints.splice(mouseNeedDeleted, 1);
	}
    if(lostLevel){
        animations['lost'].logic();
        if(hasClicked){
            reset();
            levels[currentLevel].generation();
            lostLevel = false;
        }
    }else if(!win){
        levels[currentLevel].logic();
    }else if(win){
		animations['win'].logic();
	}
    hasClicked = false;
}
</script>
</body>
</html>
